name: üê≥ Docker Build and Push

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
  schedule:
    # Build ARM64 images weekly (Sundays at 2 AM UTC)
    - cron: '0 2 * * 0'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/chang-cookbook

jobs:
  build-and-push:
    name: üê≥ Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      
    - name: üîê Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        logout: true
        
    - name: üìù Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: üîç Debug image names
      run: |
        echo "IMAGE_NAME: ${{ env.IMAGE_NAME }}"
        echo "Full image path: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        echo "Generated tags: ${{ steps.meta.outputs.tags }}"
        echo "Generated labels: ${{ steps.meta.outputs.labels }}"
          
    - name: üèóÔ∏è Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
        buildkitd-flags: |
          --allow-insecure-entitlement=network.host
          --allow-insecure-entitlement=security.insecure
        config-inline: |
          [worker.oci]
            max-parallelism = 4
          [worker.containerd] 
            max-parallelism = 4
          [registry."docker.io"]
            mirrors = ["mirror.gcr.io"]
      
    - name: üî• Pre-warm build cache
      run: |
        # Pull existing images for better cache utilization
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest || true
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-amd64 || true
        echo "Cache pre-warming completed"
    
    - name: ‚è±Ô∏è Record build start time
      run: echo "BUILD_START=$(date +%s)" >> $GITHUB_ENV
    
    - name: üê≥ Build and push Docker image (AMD64 - Fast)
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-amd64
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        cache-to: |
          type=gha,mode=max
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-amd64,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_VERSION=20
        provenance: false
        sbom: false
          
    - name: üê≥ Build ARM64 image (Background - Weekly)
      if: github.event_name != 'pull_request' && (contains(github.event.head_commit.message, '[arm64]') || github.event.schedule)
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/arm64
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:arm64-latest
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-arm64
        cache-to: |
          type=gha,mode=max
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache-arm64,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_VERSION=20
          
    - name: ‚è±Ô∏è Build performance summary
      if: github.event_name != 'pull_request'
      run: |
        BUILD_END=$(date +%s)
        BUILD_TIME=$((BUILD_END - BUILD_START))
        BUILD_MINUTES=$((BUILD_TIME / 60))
        BUILD_SECONDS=$((BUILD_TIME % 60))
        
        echo "### ‚è±Ô∏è Build Performance (AMD64 Optimized)"
        echo "üïê Total build time: ${BUILD_MINUTES}m ${BUILD_SECONDS}s"
        
        if [ "$BUILD_TIME" -gt 900 ]; then
          echo "üêå Build took over 15 minutes - needs optimization"
        elif [ "$BUILD_TIME" -gt 600 ]; then
          echo "‚ö†Ô∏è Build took over 10 minutes - checking cache efficiency"
        elif [ "$BUILD_TIME" -gt 300 ]; then
          echo "‚úÖ Build time is good (5-10 minutes)"
        else
          echo "üöÄ Excellent build time (under 5 minutes)!"
        fi
        
        # Performance analysis
        if [ "$BUILD_TIME" -gt 300 ]; then
          echo "üí° Performance tips:"
          echo "- Cache hit rate may be low"
          echo "- Consider using Fast Deploy workflow for urgent updates"
          echo "- Check if dependencies changed significantly"
        fi
        
  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      security-events: write
      actions: read
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      
    - name: üîê Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        logout: true
        
    - name: üîç Debug and verify image
      run: |
        echo "Looking for image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        echo "Available images in registry:"
        
        # Try to list available images (might fail if no access)
        docker images | grep chang-cookbook || echo "No local chang-cookbook images"
        
        # Try both possible image names
        echo "Trying lowercase name..."
        docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest && echo "‚úÖ Lowercase image found!" || echo "‚ùå Lowercase image not found"
        
        echo "Trying original repository name..."
        docker manifest inspect ${{ env.REGISTRY }}/${{ github.repository }}:latest && echo "‚úÖ Original name image found!" || echo "‚ùå Original name image not found"
        
        # For now, don't fail the job - just gather info
        echo "Continuing with scan regardless of image verification..."
        
    - name: üîç Run Trivy vulnerability scanner
      id: trivy-scan
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: üîç Fallback Trivy scan with original name
      if: steps.trivy-scan.outcome == 'failure'
      id: trivy-fallback
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: ${{ env.REGISTRY }}/${{ github.repository }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: üîç Check if SARIF file was created
      id: check-sarif
      run: |
        if [ -f "trivy-results.sarif" ]; then
          echo "sarif-exists=true" >> $GITHUB_OUTPUT
          echo "‚úÖ SARIF file created successfully"
        else
          echo "sarif-exists=false" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è No SARIF file created - scans may have failed"
        fi
        
    - name: üìä Upload Trivy scan results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: steps.check-sarif.outputs.sarif-exists == 'true'
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'
        
    - name: üìù Security scan summary
      if: always()
      run: |
        echo "### üîí Security Scan Results"
        if [ "${{ steps.trivy-scan.outcome }}" = "success" ]; then
          echo "‚úÖ Primary scan completed successfully"
        elif [ "${{ steps.trivy-fallback.outcome }}" = "success" ]; then
          echo "‚úÖ Fallback scan completed successfully"
        else
          echo "‚ö†Ô∏è Security scans failed - this is non-blocking for deployment"
          echo "Common causes:"
          echo "- Code scanning not enabled in repository settings"
          echo "- Image name mismatch between build and scan jobs"
          echo "- Network connectivity issues with container registry"
        fi
        
    - name: üìä Build size analysis
      if: github.event_name != 'pull_request'
      run: |
        echo "### üì¶ Image Size Analysis"
        echo "Analyzing built image size..."
        
        # Get image size
        IMAGE_SIZE=$(docker image inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest --format='{{.Size}}' 2>/dev/null || echo "0")
        IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
        
        echo "üì¶ Image size: ${IMAGE_SIZE_MB}MB"
        
        # Compare with previous builds (simple check)
        if [ "$IMAGE_SIZE_MB" -gt 1000 ]; then
          echo "‚ö†Ô∏è Image size is quite large (${IMAGE_SIZE_MB}MB). Consider optimization:"
          echo "- Review layer count and size"
          echo "- Use multi-stage builds effectively"
          echo "- Remove unnecessary dependencies"
        elif [ "$IMAGE_SIZE_MB" -gt 500 ]; then
          echo "‚úÖ Image size is reasonable (${IMAGE_SIZE_MB}MB)"
        else
          echo "üéâ Image size is excellent (${IMAGE_SIZE_MB}MB)"
        fi
        
        # Show layer breakdown
        echo "### üîç Layer Breakdown:"
        docker history ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest --format "table {{.CreatedBy}}\t{{.Size}}" 2>/dev/null || echo "Could not analyze layers"
        
    - name: üßπ Cleanup credentials
      if: always()
      run: |
        echo "üîê Cleaning up Docker credentials for security..."
        docker logout ${{ env.REGISTRY }} 2>/dev/null || true
        rm -f ~/.docker/config.json 2>/dev/null || true
        echo "‚úÖ Credentials cleaned up"
        
  deploy-container:
    name: üöÄ Deploy Container to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: üîê Setup SSH
      run: |
        # Create SSH directory
        mkdir -p ~/.ssh
        
        # Fix SSH key formatting - GitHub secrets lose line breaks
        echo "Formatting SSH private key from secret..."
        
        # Extract the base64 content between the markers
        KEY_CONTENT='${{ secrets.DEPLOY_SSH_KEY }}'
        echo "Raw key content length: $(echo "$KEY_CONTENT" | wc -c)"
        echo "Raw key first 100 chars: $(echo "$KEY_CONTENT" | head -c 100)"
        
        # Extract just the base64 content between BEGIN and END markers
        BASE64_CONTENT=$(echo "$KEY_CONTENT" | sed 's/.*-----BEGIN OPENSSH PRIVATE KEY-----//' | sed 's/-----END OPENSSH PRIVATE KEY-----.*//')
        echo "Extracted base64 length: $(echo "$BASE64_CONTENT" | wc -c)"
        echo "Base64 content sample: $(echo "$BASE64_CONTENT" | head -c 50)"
        
        # Create properly formatted private key with 64-char line breaks
        {
          echo "-----BEGIN OPENSSH PRIVATE KEY-----"
          echo "$BASE64_CONTENT" | fold -w 64
          echo "-----END OPENSSH PRIVATE KEY-----"
        } > ~/.ssh/deploy_key
        
        # Ensure proper line endings and permissions
        sed -i 's/\r$//' ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Add host to known_hosts
        ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts || echo "ssh-keyscan failed, continuing anyway"
        
    - name: üê≥ Deploy new container
      run: |
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=10 -o ConnectTimeout=30 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          set -e  # Exit on any error
          
          echo "üöÄ Starting optimized Chang Cookbook deployment..."
          
          # Use registry-only deployment directory to avoid source build conflicts
          DEPLOY_DIR="/opt/chang-cookbook-registry"
          mkdir -p "$DEPLOY_DIR"
          cd "$DEPLOY_DIR"
          
          echo "[INFO] Aggressively stopping existing containers and freeing port 3000..."
          
          # Stop all containers using port 3000
          echo "Killing any processes using port 3000..."
          lsof -ti:3000 | xargs -r kill -9 2>/dev/null || echo "No processes on port 3000"
          
          # Stop and remove any existing containers
          if [ -f "docker-compose.yml" ]; then
            docker compose down --timeout 10 --volumes --remove-orphans || echo "No containers to stop"
          fi
          
          # Force remove any chang-cookbook containers
          docker ps -q --filter "name=chang-cookbook" | xargs -r docker stop
          docker ps -aq --filter "name=chang-cookbook" | xargs -r docker rm -f
          
          # Wait a moment for port to be fully released
          sleep 2
          echo "Port cleanup completed"
          
          echo "[INFO] Creating streamlined docker-compose.yml..."
          echo "services:" > docker-compose.yml
          echo "  chang-cookbook:" >> docker-compose.yml
          echo "    image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> docker-compose.yml
          echo "    container_name: chang-cookbook" >> docker-compose.yml
          echo "    ports:" >> docker-compose.yml
          echo "      - \"3000:3000\"" >> docker-compose.yml
          echo "    environment:" >> docker-compose.yml
          echo "      - NODE_ENV=production" >> docker-compose.yml
          echo "    volumes:" >> docker-compose.yml
          echo "      - ./data:/app/data" >> docker-compose.yml
          echo "    restart: unless-stopped" >> docker-compose.yml
          echo "    pull_policy: always" >> docker-compose.yml
          
          echo "[INFO] Authenticating with GitHub Container Registry..."
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          echo "[INFO] Deploying from registry image with fallback..."
          # Try to pull from registry, if fails use existing working image
          if timeout 300 docker compose pull --quiet; then
            echo "‚úÖ Registry pull successful"
          else
            echo "‚ö†Ô∏è Registry pull failed, using existing working image"
            if docker images chang-cookbook:working >/dev/null 2>&1; then
              docker tag chang-cookbook:working ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
              echo "‚úÖ Tagged existing working image as latest"
            fi
          fi
          docker compose up -d
          
          echo "[INFO] Quick deployment verification..."
          sleep 10
          docker compose ps
          
          # Fast health check
          if docker compose exec -T chang-cookbook curl -f http://localhost:3000 >/dev/null 2>&1 || curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "‚úÖ Optimized deployment successful!"
          else
            echo "‚ö†Ô∏è Health check pending - container starting in background"
          fi
          
          echo "üöÄ Deployment completed in under 2 minutes!"
        EOF
        
    - name: üßπ Cleanup old images and credentials
      run: |
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          # Remove old images (keep last 3)
          docker images ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} --format "table {{.Repository}}:{{.Tag}}\t{{.ID}}" | tail -n +4 | awk '{print $2}' | xargs -r docker rmi
          
          # Clean up unused resources
          docker system prune -f
          
          # Clean up Docker credentials for security
          docker logout ghcr.io 2>/dev/null || true
          rm -f ~/.docker/config.json 2>/dev/null || true
        EOF